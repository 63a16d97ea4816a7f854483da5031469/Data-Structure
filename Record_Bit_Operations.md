# Java中的位运算
http://www.cnblogs.com/dazhaxie/archive/2012/06/28/2567080.html

	Java 中的位运算(转)
	原作者：Rosen Jiang  出处：http://www.blogjava.net/rosen
	
	移位运算符
	
	    包括：
	    “>> 右移”；“<< 左移”；“>>> 无符号右移”
	
	例子：
	-5>>3=-1
	1111 1111 1111 1111 1111 1111 1111 1011
	1111 1111 1111 1111 1111 1111 1111 1111
	其结果与 Math.floor((double)-5/(2*2*2)) 完全相同。
	
	-5<<3=-40
	1111 1111 1111 1111 1111 1111 1111 1011
	1111 1111 1111 1111 1111 1111 1101 1000 
	其结果与 -5*2*2*2 完全相同。
	
	5>>3=0
	0000 0000 0000 0000 0000 0000 0000 0101
	0000 0000 0000 0000 0000 0000 0000 0000
	其结果与 5/(2*2*2) 完全相同。
	
	5<<3=40
	0000 0000 0000 0000 0000 0000 0000 0101
	0000 0000 0000 0000 0000 0000 0010 1000
	其结果与 5*2*2*2 完全相同。
	
	-5>>>3=536870911      
	1111 1111 1111 1111 1111 1111 1111 1011
	0001 1111 1111 1111 1111 1111 1111 1111
	
	无论正数、负数，它们的右移、左移、无符号右移 32 位都是其本身，比如 -5<<32=-5、-5>>32=-5、-5>>>32=-5。
	一个有趣的现象是，把 1 左移 31 位再右移 31 位，其结果为 -1。
	0000 0000 0000 0000 0000 0000 0000 0001
	1000 0000 0000 0000 0000 0000 0000 0000
	1111 1111 1111 1111 1111 1111 1111 1111
	
	
	位逻辑运算符
	
	    包括：
	    & 与；| 或；~ 非（也叫做求反）；^ 异或
	
	    “& 与”、“| 或”、“~ 非”是基本逻辑运算，由此可以演变出“与非”、“或非”、“与或非”复合逻辑运算。“^ 异或”是一种特殊的逻辑运算，对它求反可以得到“同或”，所以“同或”逻辑也叫“异或非”逻辑。
	
	例子：
	5&3=1
	0000 0000 0000 0000 0000 0000 0000 0101
	0000 0000 0000 0000 0000 0000 0000 0011
	0000 0000 0000 0000 0000 0000 0000 0001
	
	-5&3=3
	1111 1111 1111 1111 1111 1111 1111 1011
	0000 0000 0000 0000 0000 0000 0000 0011
	0000 0000 0000 0000 0000 0000 0000 0011
	
	5|3=7
	0000 0000 0000 0000 0000 0000 0000 0101
	0000 0000 0000 0000 0000 0000 0000 0011
	0000 0000 0000 0000 0000 0000 0000 0111
	
	-5|3=-5
	1111 1111 1111 1111 1111 1111 1111 1011
	0000 0000 0000 0000 0000 0000 0000 0011
	1111 1111 1111 1111 1111 1111 1111 1011
	
	~5=-6
	0000 0000 0000 0000 0000 0000 0000 0101
	1111 1111 1111 1111 1111 1111 1111 1010
	
	~-5=4
	1111 1111 1111 1111 1111 1111 1111 1011
	0000 0000 0000 0000 0000 0000 0000 0100
	
	5^3=6
	0000 0000 0000 0000 0000 0000 0000 0101
	0000 0000 0000 0000 0000 0000 0000 0011
	0000 0000 0000 0000 0000 0000 0000 0110
	
	-5^3=-8
	1111 1111 1111 1111 1111 1111 1111 1011
	0000 0000 0000 0000 0000 0000 0000 0011
	1111 1111 1111 1111 1111 1111 1111 1000
	
	 
	
	===================================================================
	
	Java中的位操作指定包括：
	
	~ 按位非（NOT） 
	& 按位与（AND） 
	| 按位或（OR） 
	^ 按位异或（XOR） 
	>> 右移 
	>>> 无符号右移 
	<<左移 
	前面几个都非常简单,主要是移位操作比较容易出错. 
	首先要搞清楚参与运算的数的位数，如int的是32位。long的是64位。 
	如int i = 1; 
	i的二进制原码表示为： 
	00000000000000000000000000000001 
	long l = 1; 
	l的二进制原码表示为： 
	0000000000000000000000000000000000000000000000000000000000000001 
	二、
	
	正数没有反码、补码，也可以说正数的反码、补码跟原码一样。 
	负数的反码为原码逐位取反， 
	如int i = -1; 
	10000000000000000000000000000001,最高位是符号位。正数为0，负数为1。 
	逐位取反后： 
	01111111111111111111111111111110即反码。 
	反码加1： 
	01111111111111111111111111111111即补码。 
	负数都是用补码参与运算的。得到的也是补码，需要减1取反获得原码。
	
	三、常用的位运算符--0在位运算中是比较特殊的。
	
	^ 异或。 相同为0，相异为1； 任何数与0异或都等于原值。　 
	& 与。 全1为1， 有0为0；任何数与0异或都等于0。 
	| 或。 有1为1， 全0为0。任何数与0或都等于原值。 
	<<左移。 补0。 
	>> 右移。 符号位是0补0，是1补1。 
	>>>无符号右移。补0。 
	~ 非 逐位取反
	
	四、负数参与的运算，得到的是补码，需要将补码先减1，然后逐位取反，得到原码。即为运算结果。
	
	0例外，如果得到的是0，则不需减1和取反。 
	另外，两个正数运算后得到的就是原码,不需减1和取反。 
	举例： 
	1＾-1, 
	-1 
	10000000000000000000000000000001--原码 
	01111111111111111111111111111110--反码 
	01111111111111111111111111111111--补码 
	1 
	00000000000000000000000000000001--原码 
	则1^-1等于 
	01111111111111111111111111111111^ 
	00000000000000000000000000000001= 
	01111111111111111111111111111110--补码 
	01111111111111111111111111111101--反码 
	10000000000000000000000000000010--原码==-2 
	即1^-1=-2 
	举例： 
	1^-2 
	-2 
	10000000000000000000000000000010--原码 
	01111111111111111111111111111101--反码 
	01111111111111111111111111111110--补码 
	1 
	00000000000000000000000000000001--原码 
	则1^-2等于 
	01111111111111111111111111111110^ 
	00000000000000000000000000000001= 
	01111111111111111111111111111111--补码 
	01111111111111111111111111111110--反码 
	10000000000000000000000000000001--原码==-1 
	1.<< 
	逻辑左移,右边补0,符号位和其他位一样. 
	正数: 
	x<<1一般相当于2x,但是可能溢出. 
	溢出范围: 230~(231-1) 二进制表示 010000...000到01111....1111,移位后最高为变为1了,变成负数了. 
	负数: 
	x<<1一般也相当于2x,也有可能溢出.所以， x*32可以写成x<<5 
	溢出范围: -231~-(230+1)二进制表示10000...000到101111...1111,移位后最高为变成0了,变成正数了. 
	2.>> 
	算术右移,和上面的不对应,为正数时左边补0,为负数时左边补1. 
	x>>1,相当于x/2,余数被舍弃,因为这个是缩小,所以不会溢出. 
	不过有一点要注意: -1右移多少位都是-1. 
	另外舍弃的余数是正的, 3>>1=1 舍弃的余数是1. 
	-3>>1=-2 舍弃的余数也是1,而不是-1. 
	对于正数 x>>1和x/2相等 
	对于负数 x>>1和x/2不一定相等. 
	3.>>> 
	逻辑右移,这个才是和<<对应的 
	这个把符号位一起移动,左边补0 
	对于正数,>>>和>>是一样的 
	对于负数,右移之后就变成正数了. 
	可以使用Integer.toBinaryString(int i)来看01比特,更加直观. 
	考虑下面的代码： 
	for (val = 0; val < 100000; val +=5) { alterX = val * 8; myResult = val * 2; } 
	用移位操作替代乘法操作可以极大地提高性能。下面是修改后的代码： 
	for (val = 0; val < 100000; val += 5) { alterX = val << 3; myResult = val << 1; } 
	修改后的代码不再做乘以8的操作，而是改用等价的左移3位操作，每左移1位相于乘以2。相应地，右移1位操作相当于除以2。值得一提的是，虽然移位操作速度快，但可能使代码比较难于理解，所以最好加上一些注释。
	
	
	无符号右移位操作符“>>>”在将bit串右移位时，从bit串的最左边填充0，这和带符号右移位操作符“>>”不同。“>>”在将bit串右移位时，从bit串的最左边填充原来最左边的位。也就是说，bit串原来最左边的位是符号位，如果为1，则在带符号右移时最左边始终填充1；如果为0，则在带符号右移时最左边始终填充0。
	
	移位操作符的例子见下表。
	
	 
	
	操作	结果	说明
	00110010 << 2	11001000	右边始终填充0
	00110010 >> 2	00001100	结果一样
	00110010 >>> 2	00001100
	10110010 >> 2	11101100	结果不同
	10110010 >>> 2	00101100
	
	“按位与”操作符“&”对两个bit串按位进行逻辑与，“按位或”操作符“|”对两个bit串按位进行逻辑或，“按位异或”操作符“^”对两个bit串按位进行异或操作。运算规则如下表所示。
	
	 
	
	 
	
	按位与	按位或	按位异或
	0 & 0 = 0	0 | 0 = 0	0 ^ 0 = 0
	0 & 1 = 0	0 | 1 = 1	0 ^ 1 = 1
	1 & 0 = 0	1 | 0 = 1	1 ^ 0 = 1
	1 & 1 = 1	1 | 1 = 1	1 ^ 1 = 0
	
## 负数的表示

负数在计算机内部是用补码表示的  
例如 -1  
1的原码是 0000 0001  
则-1的反码是 1111 1110  
补码是 1111 1111  

所以 -1在计算机中表示为 1111 1111  

计算机中的符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。


1、一个负整数（或原码）与其补数（或补码）相加，和为模。
2、对一个整数的补码再求补码，等于该整数自身。
3、补码的正零与负零表示方法相同。

两种由原码求补码的方式：

（一）：ones' complement：这种表示法中，正数保持不变（因为这个方案就是要解决有效地将减法运算变成加负数的运算，所以，正数不需要变动，这里的反，就是相对于正数的二进制形式来说的），负数用公式  [1]  （n为将符号位算在内的位数）计算。可以形象的将对应的正数的二进制形式的各个位取反即可。(这里和得到反码的步骤不一样。反码，补码，都是从原码开始操作得到。这里是从正数开始操作得到。但两者除了计算的起点不同，最终得到的编码形式是这样的。为了区别操作过程的不同，故仍然采用英文名。)
用四位二进制数做例子。那么-7的二进制（0111）各各位取反得到其ones complement数（1000）。就是其中最左边的一位为符号位。N=7 ,n=4,带入公式，得  =-7以及其二进制形式，过程如下：


（二）：twos complement：由于上面一种表示法  [1]  (n为将符号位算在内的位数）
观察公式，twos complement数，相当于ones complement 数+1.
下面用4位二进制数来做例子：
2^{4}= 10000 2^{4}= 10000
减7 - 0111 减负7 - 1001



##lowbit
Lowbit(x)=x&-x

首先计算nums数组中所有数字的异或，记为xor

令lowbit = xor & -xor，lowbit的含义为xor从低位向高位，第一个非0位所对应的数字

例如假设xor = 6（二进制：0110），则-xor为（二进制：1010，-6的补码，two's complement）

则lowbit = 2（二进制：0010）

根据异或运算的性质，“同0异1”

记只出现一次的两个数字分别为a与b

可知a & lowbit与b & lowbit的结果一定不同

通过这种方式，即可将a与b拆分开

##线段树
http://baike.baidu.com/link?url=lPb3TbWCicEuLd_bOCI-sXeCXgDECQ1HdoujZbjUDvYxyzUgSgxfM5kPL7rCbpHTnFp30rQzYIZaWvScwOrbA_


### another OJ
http://acdream.info/problem?pid=1154
### another OJ
http://www.lintcode.com/zh-cn/problem/single-number-iii/

http://www.jiuzhang.com/solutions/single-number-iii/


