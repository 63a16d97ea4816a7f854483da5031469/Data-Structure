
/*
 * 
https://blog.csdn.net/qq_35580883/article/details/79086078

https://blog.csdn.net/u013132035/article/details/80554731


14 June 2020 at 8.43 pm


对题目易错地方进行总结:


对题目的实现思路进行几句话总结:


从这道题目学到了什么，哪些地方需要提升? :




 * 
 */




public static int countBitDiff(int num1, int num2){
    return Integer.bitCount(num1^num2);   
}



Java获得两个整型二进制表示的不同位的个数的几种方法

TimeTDIT 2018-01-17 16:19:32   917   收藏
分类专栏： 算法
版权
    我们知道整型可以用二进制表示，那么我们如何获得两个整型二进制的不同位个数呢？本文来探讨一下这个问题，如果有其他思路欢迎补充。



一、先对这两个整型进行异或，然后使用Java的API获得异或结果中1的个数：

    public static int countBitDiff(int num1, int num2){
        return Integer.bitCount(num1^num2);   
    }

    使用这种方法一行代码就可以获得结果。num1^num2之后1个个数就表示num1和num2不同的位数，然后使用Integer的静态方法bitCount()来计算num1和num2中1个个数，这样就得到了结果。那么Integer.bitCount()是如何实现的呢？看jdk源码：

    public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }

    本质上实际是二分法，两两一组相加，之后四个四个一组相加，接着八个八个，最后就得到各位之和了。 第一行是计算每两位中的 1 的个数 , 并且用该对应的两位来存储这个个数 , 如 : 01101100 -> 01011000 , 即先把前者每两位分段 01 10 11 00 , 分别有 1 1 2 0 个 1, 用两位二进制数表示为 01 01 10 00, 合起来为 01011000. 第二行是计算每四位中的 1 的个数 , 并且用该对应的四位来存储这个个数 . 如 : 01101100 经过第一行计算后得 01011000 , 然后把 01011000 每四位分段成 0101 1000 , 段内移位相加 : 前段 01+01 =10 , 后段 10+00=10, 分别用四位二进制数表示为 0010 0010, 合起来为 00100010 . 下面的各行以此类推 , 分别计算每 8 位 ,16 位 ,32 位中的 1 的个数 . 将 0x55555555, 0x33333333, 0x0f0f0f0f 写成二进制数的形式就容易明白了 。


二、先对这两个整型进行异或，然后利用小技巧计算1的位数：

public static int countBitDiff(int num1, int num2) {       
    int dif=num1^num2;
    int count=0;
    while(dif!=0){
        dif&=(dif-1);
        count++;
    }
    return count;
}

    这里前面的思路还是一样的，先利用num1和num2进行异或操作得到dif结果，dif中1的位数就是num1和num2中不同的位数。这里有一个小技巧，只要dif不等于0，利用dif&=(dif-1)的次数来计算dif中1的个数，dif&=(dif-1)的作用是把dif中最后一个1变成0,我们每次使用dif&=(dif-1)并于0比较，如果此时不为零，说明在最后一位之前还存在1，循环执行dif&=(dif-1)的次数就是dif中1的个数。


三、每次都分别将这两个整型右移1位，然后取低位比较，计算不同的位数的个数：

    public static int countBitDiff4(int num1, int num2){
        int count = 0;
        for(int i = 0;i<32;i++){
            if((num1&1)!=(num2&1)){
                count++;
            }
            num1>>=1;
            num2>>=1;
        }
        return count;
    }

    这个思路其实和我们将十进制转化为二进制时候的思路是差不多的，只不过这里每次右移之后与1取与，从而获得整型的最低位，然后与另一个整型的最低位相比较。


四、还是先对两个整型取异或，然后转化为字符串，将该字符串的0替换为""，剩下的1的个数就是不同的位数：

    public static int countBitDiff5(int num1, int num2){
        String str=Integer.toBinaryString(num1^num2);
        str=str.replaceAll("0","");
        return str.length();

————————————————
版权声明：本文为CSDN博主「TimeTDIT」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_35580883/article/details/79086078




二进制中1的个数（Java）

不贰过先生 2018-06-03 11:19:45   1474   收藏 1
分类专栏： 剑指offer  面试-剑指offer刷题小结
版权
题目：

请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

知识点：

这道题是考查位运算。位运算一共有5种：与、或、异或、左移和右移。

与运算特点：全真为真；或运算特点：全假为假；异或运算的特点：相同为假。

左移：m<<n，表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0。

右移：m>>n，表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。注：如果数字是一个无符号值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。（符号位为0填补0，符号位为1填补1）。

第一想法：

先判断整数二进制表示中的最右边一位是不是1。接着把输入的整数右移一位，此时原来还处于右边数起的第二位被移到最右边了，再判断是不是1。这样每次移动一位，直到整个整数变成0为止。（判断是不是的条件是整数和1做位与运算看结果是不是0就知道了）。

实现代码：

public int numberOf1(int n){
	int count = 0;
	while(n!=0){
		if((n&1) != 0){
			++count;
		}
		n = n >> 1;
	}
	return count;
}
但是从上面的右移规则的定义可以看出如果符号位为1时，这个程序会陷入死循环。故这个代码符合符号位不为1的题目。

改良思路：

为了避免死循环的发生，我们不右移数字n。我们左移1，即首先把n和1做位与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.....，这样反复左移，每次都能判断n的其中一位是不是1。

实现代码：

public int numberOfs1(int n){
	int count = 0;
	int flag = 1;
	while(flag!=0){
		if((n&flag) != 0){
			++count;
		}
		flag = flag << 1;
	}
	return count;
}
优化思路：

把一个整数减去1，再和原来整数做与运算，会把该整数最右边一个1变成0,。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。

public int numbersOf1(int n){
	int count = 0;
	while(n != 0){
		++count;
		n = (n-1) & n;
	}
	return count;
}
小结：

考查对二进制及位运算的理解。以及思考问题的全面性。

拓展题：

题目：

用一条语句判断一个整数是不是2的整数次方。

思路：

一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0。故把这个待测整数减去1后再和它自己做与运算，这个整数中唯一的1就会变成0。

代码：

public boolean judgeNum2Square(int num){
	if((num & (num-1)) != 0){
		return false;
	}else{
		return true;
	}
}
题目：

输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如：10的二进制位1010，13的二进制位1101，1010改变3位才能变成1101。

思路：

第一步求这两个数的异或结果；第二步统计异或结果中1的位数。

代码：

public int changeCount(int n, int m){
	int count = 0;
	int x = n^m;
	while(x!=0){
		++count;
		x = (x-1) & x;
	}
		return count;
}
小思：

把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。这个方法在解决很多二进制问题都可以用。

小结：

基础很重要啊，充分理解位运算。
————————————————
版权声明：本文为CSDN博主「不贰过先生」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013132035/article/details/80554731








