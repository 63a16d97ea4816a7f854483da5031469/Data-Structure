具体这次复习分为几个部分：

>从心态上看，算法是一个套路和实践双结合的问题，就是套路要知道，练得要足够，手够热。

>读面经，有助于快速吸收知识，补足不懂的地方，提问是引起检查知识缺陷和快速进入面试状态的一种方式

1. 广泛的过一遍知识点，在状态好的时候，写题目，在状态不好的时候，见缝插针读题目。唤醒和加强记忆技法。
2. 实际去写题目，进行一些简单的预备，进入考试和面试的那种状态。
3. 复习一下相关的java知识点
4. 复习一下现有的工作的知识点


**基础结构**

	/**
	 * Definition for a binary tree node.
	 * public class TreeNode {
	 *     int val;
	 *     TreeNode left;
	 *     TreeNode right;
	 *     TreeNode(int x) { val = x; }
	 * }
	 */

LinkedList<Integer> list=new LinkedList<>();
PriorityQueue<Integer> pq=new PriorityQueue<>((o1,o2)->{
	return o2-o1;
});
for(Map.Entry<String,String> tmp:map.entrySet()){
	System.out.println(tmp.getKey()+"->"+tmp.getValue());
}
for(String tmp:map.KeySet()){
	System.out.println(tmp);
}

HashSet<String> set=new HashSet<>();
for(String tmp:set){
	System.out.println(tmp);
}

table.foreach(
(key,value) - > {
	System.out.println(key+" "+value); 
}
Stack<Integer> stack=new Stack<>();
stack.push(a);
stack.pop();
stack.peek();
stack.size();
while(stack.isEmpty()){
	
}



**数组**，       ====> OK

如何找到数组中的奇数节点，和偶数节点 i%2==0

给一个数组，实现奇数位置从大到小排列，偶数位置从小到大排列 （LinkedList, sort, 一个从removeFirst()，一个从removeLast()拿, 偶数节点 i%2==0
1 , 2，3，4

	int[] a=new int[]{1,2,3,4};
	int size=a.length;
	List<Integer> list=Arrays.asList(a);
	Arrays.sort(a);

* 数组经常考双指针。
* 快慢指针。
* 移除0。
* 桶排序。

**字符串**，       ====> OK

	String --->  str.length();  

**矩阵**，

int[][] a =new int[m][n];


* 矩阵这种，经常在DP中用到


**链表**
prev、cur、next 

* 链表要注意边界条件（链表为空情况）
*  合并两个有序链表
*  给定一个链表的头结点，也给定这个结点的指针，在O(1)的时间删除该节点（例如该节点为target), target=target.next;
*  找到单链表第k个节点。

* 将链表逆转
* 拼接两个有序链表
* 删除单链表倒数第 n 个节点(里面有两种情况）

* 求单链表的中间节点(快慢指针）
* 快慢指针，有环没环

* 找到环的入口点（要理解证明过程）
* 求两个无环单链表的第一个相交点（第一个公共交点）

![](./images/cycleEntrypoint.png)
> 
> 　有环时查找入环点的方法的证明过程如下：
> 　　当fast与slow相遇时，slow还没走完链表，而fast已经在环内循环了n圈了，假设slow在相遇前走了s步，则fast走了2s步，设环长为r，有2s=s+nr，即s=nr.
> 　　由上图可知a+x=s, x+y=r，而我们的目标是找到a的位置。设上图那个拱起的曲线的长度为y，有a+x=s=nr=(n-1)r+r=(n-1)r+y+x，则a=(n-1)r+y. 这个公式告诉我们，从链表头和相遇点分别设一个指针，每次各走一步，这两个指针必定相遇，且相遇的第一个点为环入口点。


* 判断两个无环单链表是否相交（转换为环解决，hashmap解决，或者将两个链表都移到最后一个点，因为如果相交的话，最后一个点一定是相同的）

> 无环单链表是否相交判断有多种方法：
> 方法1：先循环链表1，将每个节点的地址进行hash计算存入哈希表，然后计算链表2的每个节点的地址的hash值，若与hash表中对应位置有值，则相交，否则不相交。
> 方法2：见链表1与2进行首尾相连，判断新链表是否有环，若没有，则不相交，若有环，则是相交的。
> 方法3：先计算两个链表的长度L1、L2，若L1 > L2，则先将链表1移动（L1 - L2）个节点，等到链表1和链表2剩下的长度一样的时候，一起向后移动，依次判断当前链表的节点是否相等，若相等，则相交，若到队尾还没有相等的，则不相交

* 判断两个有环单链表是否相交


链表经典题目：
[https://www.jianshu.com/p/a2d53142860c](https://www.jianshu.com/p/a2d53142860c)

**队列**,

使用两个队列，做一个栈。(看queue1是空的话，就插入到queue2，然后将queue1的都装进来，弹出的时候，直接从有数据的那个queue直接弹出。这样就保证了后进先出。

![](images/twoqueues.png)

**堆栈**，  
使用两针堆栈，模拟一个队列
倒序打印一个单链表
stack.peek();
stack.push(x);
stack.pop();
最小栈
有效的括号

**二叉树**，固定算法结构。

构建二叉树，根据先根和中根遍历，构造二叉树。(root.left=rebuildTree(preorder, inorder, start, mid-1), root.right=rebuildTree(preorder, inorder, mid+1, end);
构建二叉树，根据后根和中跟遍历，构造二叉树。
二叉树，输出其镜像（每个节点的左右子节点交换）==》 left.val==right.val && symm(left.left,right.right) && symm(left.right,right.left)

序列化和反序列化二叉树. 
	public void serializeHelper(TreeNode root, List<String> list) {
	        if (root == null) {
	            list.add("#");
	            return;
	        }
	        list.add(String.valueOf(root.val));
	        serializeHelper(root.left, list);
	        serializeHelper(root.right, list);
	        return;
    }
	

**二叉搜索树**

判断二叉搜索树的后根遍历序列。。（二叉树右子树的值一定大于root, 先找到第一个大于root的值，这个值是右子树的根mid index，然后分别verify(postorder, start, mid-1) && verify(postorder,mid,end-1))




**排序**，  

快排。
Arrays.sort(a);
Collections.sort(b, (o1,o2)->{
     return o1-o2;
});
桶排序

**快慢指针**
判断链表是否有环，环的入口在哪里

**哈希表**，

哈希表的结构

**双指针**，两指针问题，考察运用语言基本能力，灵活解题能力。

移动零

**优先级队列**，    ====> OK

PriorityQueue 
O(nlogn)

**桶排序** ， 首先，桶的最长长度是可以确定的，然后可以根据一定的规则把所有的值分桶（topK） ====> OK 


**排列**

全排列 ===> DPS解法
全排列，但是不能有重复 ===>  DPS解法+HashSet



**回溯**，
**贪心**，
**枚举(穷举)**，即通过for loop一定可以将问题分为一类，另一类：字符串轮转，一定可以通过穷举找到所有的情况
**BFS**，即通过固定模板，先广度再下一步。

腐烂的橘子

**DFS**, 即通过固定模板，先向下搜索到末尾，再回溯。

二叉树先根遍历
电话号码的字母组合

**递归**，


**DP-动态规划**，动态规划

 打家劫舍 II
 


**二分查找**，


**快排**，


**堆排序**，


**LRU**


**Snowflake id**

