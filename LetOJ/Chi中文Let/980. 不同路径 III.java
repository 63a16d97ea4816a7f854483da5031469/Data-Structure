
/*
 * 
link: https://leetcode.cn/problems/unique-paths-iii/description/

980. 不同路径 III
困难
216
相关企业
在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

 

示例 1：

输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
示例 2：

输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4
解释：我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
示例 3：

输入：[[0,1],[2,0]]
输出：0
解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。
 

提示：

1 <= grid.length * grid[0].length <= 20


刚看到想到的思路是什么？：


意识到的边界条件是什么？：


考虑到的速度和空间复杂度是多少？：




对题目易错地方进行总结:


对题目的实现思路进行几句话总结:


从这道题目学到了什么，哪些地方需要提升? :



 * 
 */

// 错误解:
class Solution {
    int ways=0;
    public int uniquePathsIII(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    boolean[][] v=new boolean[m][n];
                    dfs(grid,v,i,j);
                }
            }
        }
        return ways;
    }

    public void dfs(int[][] grid, boolean[][] v, int x, int y){
        int m=grid.length;
        int n=grid[0].length;
        if(x<0||x>=m||y<0||y>=n||v[x][y]||grid[x][y]==-1){
            return;
        }
        
        if(grid[x][y]==2){
            // 终止符号
            ways++;
            return;
        }
        v[x][y]=true;
        System.out.println("("+x+","+y+"); ");
        int[][] dirs=new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
        for(int[] dir:dirs){
            int i=dir[0]+x;
            int j=dir[1]+y;
            System.out.print("["+i+","+j+"]; ");
            dfs(grid,v,i,j);
        }
    }
}

grid =
[[1,0,0,0],[0,0,0,0],[0,0,0,2]]


(0,0);
(1,0);
(2,0);
(2,1);
(1,1);
(0,1);
(0,2);
(1,2);
(2,2);
(1,3);
(0,3);


(0,0); 
[-1,0]; [1,0]; (1,0); 
[0,0]; [2,0]; (2,0); 
[1,0]; [3,0]; [2,-1]; [2,1]; (2,1); 
[1,1]; (1,1); 
[0,1]; (0,1); 
[-1,1]; [1,1]; [0,0]; [0,2]; (0,2); 
[-1,2]; [1,2]; (1,2); 
[0,2]; [2,2]; (2,2); 
[1,2]; [3,2]; [2,1]; [2,3]; (2,3); 
[1,1]; [1,3]; (1,3); 
[0,3]; (0,3); 
[-1,3]; [1,3]; [0,2]; [0,4]; [2,3]; (2,3); 
[1,2]; [1,4]; [0,1]; [0,3]; [2,1]; [1,0]; [1,2]; [3,1]; [2,0]; [2,2]; [1,-1]; [1,1]; [0,-1]; [0,1]; 

主要原因是,因为使用boolean[][] v, 之前的选择将一些路已经走过了,干扰了后续的搜索.


/*
@v7fgg
执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：38.5 MB, 在所有 Java 提交中击败了20.10%的用户
2022年2月6日 15:44
*/
class Solution {
    int grid[][];
    int ans=0;
    int start[];
    int countOf0=0;
    public int uniquePathsIII(int[][] grid) {
        //1：起始；2：结束；0：空；-1：障碍
        this.grid=grid;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){start=new int[]{i,j};}
                else if(grid[i][j]!=-1){countOf0++;}
            }
        }
        findPath(start[0],start[1],0);
        return ans;
    }
    public void findPath(int i,int j,int step){
        if(i<0||j<0||i==grid.length||j==grid[0].length||grid[i][j]==-1){return;}
        if(grid[i][j]==2){if(countOf0==step){ans++;}}
        else{
            int g=grid[i][j];
            grid[i][j]=-1;
            findPath(i+1,j,step+1);
            findPath(i-1,j,step+1);
            findPath(i,j+1,step+1);
            findPath(i,j-1,step+1);
            grid[i][j]=g;
        }
    }
}


grid =
[[1,0,0,0],[0,0,0,0],[0,0,0,2]]

(0,0); 
(1,0); 
(2,0); 
(2,1); 
(1,1); 
(0,1); 
(0,2); 
(1,2); 
(2,2); 
(1,3); 
(0,3); 
(0,3); 
(1,3); 
(1,2); 
(2,2); 
(1,2); 
(2,2); 
(0,2); 
(0,3); 
(1,3); 
(0,1); 
(1,3); 
(0,3); 
(0,2); 
(0,1); 
(2,2); 
(1,2); 
(0,2); 
(0,3); 
(1,3); 
(0,1); 
(1,1); 
(1,3); 
(0,3); 
(0,2); 
(0,1); 
(1,1); 
(1,1); 
(0,1); 
(0,2); 
(0,3); 
(1,3); 
(1,1); 
(2,1); 
(2,2); 
(1,2); 
(0,2); 
(0,3); 
(1,3); 
(0,1); 
(1,3); 
(0,3); 
(0,2); 
(0,1); 
(2,0); 
(0,1); 
(0,2); 
(1,2); 
(2,2); 
(2,1); 
(2,0); 
(1,3); 
(0,3); 
(0,3); 
(1,3); 
(1,2); 
(2,2); 
(2,1); 
(2,0); 
(1,2); 
(2,2); 
(2,1); 
(2,0); 
(0,2); 
(0,3); 
(1,3); 
(0,1); 
(1,3); 
(0,3); 
(0,2); 
(0,1); 
(0,1); 
(1,1); 
(2,1); 
(2,2); 
(1,2); 
(0,2); 
(0,3); 
(1,3); 
(1,3); 
(0,3); 
(0,2); 
(2,0); 
(1,0); 
(1,2); 
(2,2); 
(2,1); 
(2,0); 
(1,0); 
(0,2); 
(0,3); 
(1,3); 
(1,3); 
(0,3); 
(0,2); 
(1,0); 
(2,0); 
(2,1); 
(2,2); 
(1,2); 
(0,2); 
(0,3); 
(1,3); 
(1,3); 
(0,3); 
(0,2); 
(0,2); 
(1,2); 
(2,2); 
(2,1); 
(1,1); 
(1,0); 
(2,0); 
(2,0); 
(1,0); 
(1,1); 
(1,3); 
(0,3); 
(1,1); 
(2,1); 
(2,2); 
(2,0); 
(1,0); 
(1,0); 
(2,0); 
(2,1); 
(2,2); 
(0,3); 
(1,3); 
(1,2); 
(2,2); 
(2,1); 
(1,1); 
(1,0); 
(2,0); 
(2,0); 
(1,0); 
(1,1); 
(1,1); 
(2,1); 
(2,2); 
(2,0); 
(1,0); 
(1,0); 
(2,0); 
(2,1); 
(2,2); 




// 对于这样的测试用例也可以通过:
// 因为题目有说明 "每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。"
[[1,0,0,2],
 [0,-1,-1,-1],
 [-1,0,0,0]]


[[1,0,0,2],[0,-1,-1,-1],[-1,0,0,0]]



// 纠正之前的解法:
class Solution {
    int ways=0;
    int count=0;
    public int uniquePathsIII(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int[] start=new int[2];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){

                if(grid[i][j]==1){
                    start[0]=i;
                    start[1]=j;
                }else if(grid[i][j]!=-1){
                    // 因为是step是从0开始的,所以第一个1开始点,不算在steps
                    count++;
                }
            }
        }
        // 易错点,不能把dfs放到循环里面,
        // 如果放到循环里面,steps还没有初始化完就开始了
        dfs(grid,start[0],start[1],0);
        return ways;
    }

    public void dfs(int[][] grid, int x, int y, int step){
        int m=grid.length;
        int n=grid[0].length;
        if(x<0||x>=m||y<0||y>=n||grid[x][y]==-1){
            return;
        }
        // 因为题目有说明 "每一个无障碍方格都要通过一次，
        // 但是一条路径中不能重复通过同一个方格。"
        if(grid[x][y]==2&&count==step){
            // 终止符号
            ways++;
            return;
        }
        int g=grid[x][y];
        grid[x][y]=-1;
        int[][] dirs=new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
        for(int[] dir:dirs){
            int i=dir[0]+x;
            int j=dir[1]+y;
            dfs(grid,i,j,step+1);
        }
        grid[x][y]=g;
    }
}


